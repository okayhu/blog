<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dyhu&#39;s blog</title>
  
  
  <link href="https://okayhu.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://okayhu.github.io/blog/"/>
  <updated>2023-01-07T12:38:04.063Z</updated>
  <id>https://okayhu.github.io/blog/</id>
  
  <author>
    <name>dyhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>绑定 Spring MVC 命令对象时如何自定义参数名</title>
    <link href="https://okayhu.github.io/blog/posts/2022/spring-mvc-binding-object/"/>
    <id>https://okayhu.github.io/blog/posts/2022/spring-mvc-binding-object/</id>
    <published>2022-12-30T10:56:05.000Z</published>
    <updated>2023-01-07T12:38:04.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>Spring 提供 <code>@RequestParam</code> 来绑定 Query 参数，并且能绑定不同名称的参数。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span>pulic Page <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;current_page&quot;)</span> Integer pageNum,</span><span class="hljs-params">                <span class="hljs-meta">@RequestParam(&quot;page_size&quot;)</span> Integer pageSize)</span> &#123;    ...&#125;</code></pre></div><p>然而当用对象来接收 Query 参数时，该如何绑定不同名称的参数呢？</p><p>这是用来绑定的分页查询对象：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;    <span class="hljs-keyword">private</span> Integer pageNum;    <span class="hljs-keyword">private</span> Integer pageSize;&#125;</code></pre></div><p>对应的 Spring MVC 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span>pulic Page <span class="hljs-title function_">page</span><span class="hljs-params">(PageQuery pageQuery)</span> &#123;    ...&#125;</code></pre></div><p>它适用于<code>http://example.com/page?pageNum=1&amp;pageSize=10</code>，却不适用于以下网址：</p><p><code>http://example.com/page?current_page=1&amp;page_size=10</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>为了解决上面这个问题，我们需要扩展 <code>HandlerMethodArgumentResolver</code>，并将其添加到 Spring MVC 的 ArgumentResolvers</p><h3 id="自定义-DataBinder"><a href="#自定义-DataBinder" class="headerlink" title="自定义 DataBinder"></a>自定义 DataBinder</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestParamNameDataBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServletRequestDataBinder</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; requestParamNameMapping;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RequestParamNameDataBinder</span><span class="hljs-params">(Object target, String objectName,</span><span class="hljs-params">                                      Map&lt;String, String&gt; requestParamNameMapping)</span> &#123;        <span class="hljs-built_in">super</span>(target, objectName);        <span class="hljs-built_in">this</span>.requestParamNameMapping = requestParamNameMapping;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBindValues</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> MutablePropertyValues mpvs,</span><span class="hljs-params">                                 <span class="hljs-meta">@NotNull</span> ServletRequest request)</span> &#123;        requestParamNameMapping.forEach((from, to) -&gt; &#123;            <span class="hljs-keyword">if</span> (mpvs.contains(from)) &#123;                <span class="hljs-type">PropertyValue</span> <span class="hljs-variable">propertyValue</span> <span class="hljs-operator">=</span> mpvs.getPropertyValue(from);                mpvs.add(to, propertyValue == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : propertyValue.getValue());            &#125;        &#125;);    &#125;&#125;</code></pre></div><h3 id="自定义参数处理器"><a href="#自定义参数处理器" class="headerlink" title="自定义参数处理器"></a>自定义参数处理器</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestParamNameMethodProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServletModelAttributeMethodProcessor</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;    <span class="hljs-comment">// Rename cache</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; targetClassRequestParamNameMapping =        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();    <span class="hljs-keyword">private</span> WebBindingInitializer webBindingInitializer;    <span class="hljs-meta">@Autowired(required = false)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAdapter</span><span class="hljs-params">(RequestMappingHandlerAdapter adapter)</span> &#123;        <span class="hljs-built_in">this</span>.webBindingInitializer = adapter.getWebBindingInitializer();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RequestParamNameMethodProcessor</span><span class="hljs-params">(<span class="hljs-type">boolean</span> annotationNotRequired)</span> &#123;        <span class="hljs-built_in">super</span>(annotationNotRequired);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindRequestParameters</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> WebDataBinder binder,</span><span class="hljs-params">                                         <span class="hljs-meta">@NotNull</span> NativeWebRequest nativeWebRequest)</span> &#123;        <span class="hljs-built_in">super</span>.bindRequestParameters(binder, nativeWebRequest);        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> binder.getTarget();        Class&lt;?&gt; targetClass = Objects.requireNonNull(target).getClass();        <span class="hljs-keyword">if</span> (!targetClassRequestParamNameMapping.containsKey(targetClass)) &#123;            targetClassRequestParamNameMapping.put(targetClass, analyzeClass(targetClass));        &#125;        <span class="hljs-type">RequestParamNameDataBinder</span> <span class="hljs-variable">paramNameDataBinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestParamNameDataBinder</span>(target,            binder.getObjectName(), targetClassRequestParamNameMapping.get(targetClass));        webBindingInitializer.initBinder(paramNameDataBinder);        paramNameDataBinder.bind(            Objects.requireNonNull(nativeWebRequest.getNativeRequest(ServletRequest.class)));    &#125;    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title function_">analyzeClass</span><span class="hljs-params">(Class&lt;?&gt; targetClass)</span> &#123;        Map&lt;String, String&gt; renameMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">8</span>);        <span class="hljs-keyword">for</span> (Field field : targetClass.getDeclaredFields()) &#123;            <span class="hljs-type">RequestParamName</span> <span class="hljs-variable">requestParamName</span> <span class="hljs-operator">=</span> field.getAnnotation(RequestParamName.class);            <span class="hljs-keyword">if</span> (requestParamName != <span class="hljs-literal">null</span> &amp;&amp; StringUtils.isNotBlank(requestParamName.value())) &#123;                renameMap.put(requestParamName.value(), field.getName());            &#125;        &#125;        <span class="hljs-keyword">if</span> (targetClass.getSuperclass() != Object.class) &#123;            renameMap.putAll(analyzeClass(targetClass.getSuperclass()));        &#125;        <span class="hljs-keyword">return</span> renameMap;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        Assert.notNull(webBindingInitializer, <span class="hljs-string">&quot;webBindingInitializer must not be null!&quot;</span>);    &#125;&#125;</code></pre></div><h3 id="对应的注解"><a href="#对应的注解" class="headerlink" title="对应的注解"></a>对应的注解</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RequestParamName &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定的请求参数名称</span><span class="hljs-comment">     */</span>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;&#125;</code></pre></div><h3 id="配置-Spring-MVC-的-ArgumentResolver"><a href="#配置-Spring-MVC-的-ArgumentResolver" class="headerlink" title="配置 Spring MVC 的 ArgumentResolver"></a>配置 Spring MVC 的 ArgumentResolver</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> RequestParamNameMethodProcessor <span class="hljs-title function_">requestParamNameMethodProcessor</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestParamNameMethodProcessor</span>(<span class="hljs-literal">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123;        resolvers.add(requestParamNameMethodProcessor());    &#125;&#125;</code></pre></div><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;        <span class="hljs-meta">@RequestParamName(&quot;current_page&quot;)</span>    <span class="hljs-keyword">private</span> Integer pageNum;        <span class="hljs-meta">@RequestParamName(&quot;page_size&quot;)</span>    <span class="hljs-keyword">private</span> Integer pageSize;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;来源&quot;&gt;&lt;a href=&quot;#来源&quot; class=&quot;headerlink&quot; title=&quot;来源&quot;&gt;&lt;/a&gt;来源&lt;/h2&gt;&lt;p&gt;Spring 提供 &lt;code&gt;@RequestParam&lt;/code&gt; 来绑定 Query 参数，并且能绑定不同名称的参数。&lt;/p&gt;
&lt;d</summary>
      
    
    
    
    <category term="spring" scheme="https://okayhu.github.io/blog/categories/spring/"/>
    
    
    <category term="spring" scheme="https://okayhu.github.io/blog/tags/spring/"/>
    
    <category term="springmvc" scheme="https://okayhu.github.io/blog/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 必备设置</title>
    <link href="https://okayhu.github.io/blog/posts/2022/idea-settings/"/>
    <id>https://okayhu.github.io/blog/posts/2022/idea-settings/</id>
    <published>2022-12-17T12:25:15.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IDEA 2022.3</p></blockquote><h3 id="取消更新检查"><a href="#取消更新检查" class="headerlink" title="取消更新检查"></a>取消更新检查</h3><p>Settings ⇒ Appearance &amp; Behavior ⇒ System Settings ⇒ Updates</p><p>取消选中 <code>Check IDE update for:</code>。</p><h3 id="启动时不自动打开项目"><a href="#启动时不自动打开项目" class="headerlink" title="启动时不自动打开项目"></a>启动时不自动打开项目</h3><p>Settings ⇒ Appearance &amp; Behavior ⇒ System Settings</p><p>取消选中 Project 下的 <code>Reopen projects on startup</code>。</p><h3 id="Tab-多行展示"><a href="#Tab-多行展示" class="headerlink" title="Tab 多行展示"></a>Tab 多行展示</h3><p>Settings ⇒ Editor ⇒ General ⇒ Editor Tabs</p><p>取消选中 <code>Show tabs in one row</code>。</p><h3 id="增大-Tab-展示数量"><a href="#增大-Tab-展示数量" class="headerlink" title="增大 Tab 展示数量"></a>增大 Tab 展示数量</h3><p>默认情况， Tab 最多展示 10 个</p><p>Settings ⇒ Editor ⇒ General ⇒ Editor Tabs</p><p>修改 Closing Policy 下的 <code>Tab limit</code></p><h3 id="关闭当前-Tab-打开最近的-Tab"><a href="#关闭当前-Tab-打开最近的-Tab" class="headerlink" title="关闭当前 Tab 打开最近的 Tab"></a>关闭当前 Tab 打开最近的 Tab</h3><p>默认情况，关闭当期 Tab 后会打开左侧的 Tab。可以选择将其更改为打开最近的 Tab。</p><p>Settings ⇒ Editor ⇒ General ⇒ Editor Tabs</p><p>选中 Closing Policy 下 When the current tab is closed，activate: 的 <code>Most recently opened tab</code> 选项。</p><h3 id="代码提示不区分大小写"><a href="#代码提示不区分大小写" class="headerlink" title="代码提示不区分大小写"></a>代码提示不区分大小写</h3><p>Settings ⇒ Editor ⇒ General ⇒ Code Completion</p><p>选中 <code>Match case</code>。</p><h2 id="设置文件换行符为-LF"><a href="#设置文件换行符为-LF" class="headerlink" title="设置文件换行符为 LF"></a>设置文件换行符为 LF</h2><p>Settings ⇒ Editor ⇒ Code style</p><p>设置 General 下的 Line separator 为 <code>Unix and macOS (\n)</code>。</p><h3 id="设置文件编码格式为-UTF-8"><a href="#设置文件编码格式为-UTF-8" class="headerlink" title="设置文件编码格式为 UTF -8"></a>设置文件编码格式为 UTF -8</h3><p>Settings ⇒ Editor ⇒ File Encodings</p><p><img src="https://uposs.justokay.cn/images/idea/idea-file-encodings.png" alt="idea-file-encodings.png"></p><h3 id="自动导包优化"><a href="#自动导包优化" class="headerlink" title="自动导包优化"></a>自动导包优化</h3><p>Settings ⇒ Editor ⇒ General ⇒ Auto Import</p><p>选中 Java 下的 <code>Add unambigouts imports on the fly</code>，在编辑代码时，如果只有一个具有匹配名称的可导入声明，则自动添加导入。<br>选中 Java 下的 <code>Optimize import on the fly</code>，删除未使用的导入并根据代码样式设置重新排序导入。</p><h3 id="展示方法间的分割线"><a href="#展示方法间的分割线" class="headerlink" title="展示方法间的分割线"></a>展示方法间的分割线</h3><p>Settings ⇒ Editor ⇒ General ⇒ Appearance</p><p>选中 <code>Show method separators</code>。</p><h3 id="注释缩进"><a href="#注释缩进" class="headerlink" title="注释缩进"></a>注释缩进</h3><p>默认情况，所有使用 <code>ctrl +/</code> 快捷键的注释都是从行首开始的，没有缩进。</p><p><strong>Java</strong></p><p>Settings ⇒ Editor ⇒ Code Style ⇒ Java ⇒ Code Generation</p><p>取消选中 <code>Line Comment at first column</code>，行注释从首行开始<br>选中 <code>Add a space at line comment start</code>，在注释前加一个空格<br>取消选中 <code>Block comment at first column</code>，快注释从首行开始</p><p><img src="https://uposs.justokay.cn/images/idea/idea-codestyle-java-comment.png" alt="idea-codestyle-java-comment.png"></p><p><strong>XML</strong></p><p>Settings ⇒ Editor ⇒ Code Style ⇒ XML ⇒ Code Generation</p><p>取消选中 <code>Line Comment at first column</code>，行注释从首行开始<br>取消选中 <code>Block comment at first column</code>，快注释从首行开始</p><p><img src="https://uposs.justokay.cn/images/idea/idea-codestyle-xml-comment.png" alt="idea-codestyle-xml-comment.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;IDEA 2022.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;取消更新检查&quot;&gt;&lt;a href=&quot;#取消更新检查&quot; class=&quot;headerlink&quot; title=&quot;取消更新检查&quot;&gt;&lt;/a&gt;取消更新检查&lt;/h3&gt;&lt;p&gt;Settings</summary>
      
    
    
    
    <category term="IDEA" scheme="https://okayhu.github.io/blog/categories/IDEA/"/>
    
    
    <category term="idea" scheme="https://okayhu.github.io/blog/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>IDEA：通过 Groovy 脚本生成 Entity</title>
    <link href="https://okayhu.github.io/blog/posts/2022/idea-database-groovy/"/>
    <id>https://okayhu.github.io/blog/posts/2022/idea-database-groovy/</id>
    <published>2022-11-12T14:14:07.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IDEA-连接数据库"><a href="#IDEA-连接数据库" class="headerlink" title="IDEA 连接数据库"></a>IDEA 连接数据库</h3><p>IDEA 内置了 DataGrip 的大部分功能用于管理数据库，可在侧边栏找到，连接到数据库。</p><p><img src="https://uposs.justokay.cn/images/idea/idea-database-groovy-01.png"></p><h3 id="定位-Groovy-脚本目录"><a href="#定位-Groovy-脚本目录" class="headerlink" title="定位 Groovy 脚本目录"></a>定位 Groovy 脚本目录</h3><p>IDEA 已经内置了几个用于生成模型类的脚本，我们可以根据自己需求创建自己的脚本。</p><p>在任意表中右键选择脚本扩展 - 转到脚本目录。</p><p><img src="https://uposs.justokay.cn/images/idea/idea-database-groovy-02.png"></p><p>点击 <code>Go To Scripts Directory</code> 然后就可以看到内置的脚本文件，双击就可以编辑，也可以新增。</p><p><img src="https://uposs.justokay.cn/images/idea/idea-database-groovy-03.png"></p><h3 id="编写-Groovy-脚本文件"><a href="#编写-Groovy-脚本文件" class="headerlink" title="编写 Groovy 脚本文件"></a>编写 Groovy 脚本文件</h3><p>下面这个脚本是基于 <code>MyBatis-Plus + Lombok</code> 的：</p><div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> com.intellij.database.model.DasTable<span class="hljs-keyword">import</span> com.intellij.database.util.Case<span class="hljs-keyword">import</span> com.intellij.database.util.DasUtil<span class="hljs-comment">/*</span><span class="hljs-comment"> * Available context bindings:</span><span class="hljs-comment"> *   SELECTION   Iterable&lt;DasObject&gt;</span><span class="hljs-comment"> *   PROJECT     project</span><span class="hljs-comment"> *   FILES       files helper</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Tips: the script does  not support the composite primary key</span><span class="hljs-comment"> */</span>packageName = <span class="hljs-string">&quot;&quot;</span>existsPrimaryKey = <span class="hljs-literal">false</span>;primaryKeyAutoGenerated = <span class="hljs-literal">false</span>;typeMapping = [        (<span class="hljs-regexp">~/(?i)tinyint|bool|boolean|bit/</span>)        : <span class="hljs-string">&quot;Boolean&quot;</span>,        (<span class="hljs-regexp">~/(?i)bigint/</span>)                          : <span class="hljs-string">&quot;Long&quot;</span>,        (<span class="hljs-regexp">~/(?i)smallint|mediumint|int|integer/</span>)  : <span class="hljs-string">&quot;Integer&quot;</span>,        (<span class="hljs-regexp">~/(?i)float/</span>)                           : <span class="hljs-string">&quot;Float&quot;</span>,        (<span class="hljs-regexp">~/(?i)double/</span>)                          : <span class="hljs-string">&quot;Double&quot;</span>,        (<span class="hljs-regexp">~/(?i)decimal/</span>)                         : <span class="hljs-string">&quot;BigDecimal&quot;</span>,        (<span class="hljs-regexp">~/(?i)date|datetime|timestamp|time/</span>)    : <span class="hljs-string">&quot;Date&quot;</span>,        (<span class="hljs-regexp">~/(?i)char|varchar|text|json/</span>)          : <span class="hljs-string">&quot;String&quot;</span>,        (<span class="hljs-regexp">~/(?i)blob|binary|bfile|clob|raw|image/</span>): <span class="hljs-string">&quot;InputStream&quot;</span>,        (<span class="hljs-regexp">~/^(?i)/</span>)                               : <span class="hljs-string">&quot;String&quot;</span>]FILES.chooseDirectoryAndSave(<span class="hljs-string">&quot;Choose directory&quot;</span>, <span class="hljs-string">&quot;Choose where to store generated files&quot;</span>) &#123; dir -&gt;    SELECTION.filter &#123; it <span class="hljs-keyword">instanceof</span> DasTable &#125;.each &#123; generate(it, dir) &#125;&#125;<span class="hljs-keyword">def</span> generate(table, dir) &#123;    <span class="hljs-keyword">def</span> className = javaName(table.getName(), <span class="hljs-literal">true</span>)    <span class="hljs-keyword">def</span> fields = calcFields(table)    packageName = getPackageName(dir)    <span class="hljs-keyword">new</span> File(dir, className + <span class="hljs-string">&quot;.java&quot;</span>).withPrintWriter(<span class="hljs-string">&quot;UTF-8&quot;</span>) &#123; out -&gt; generate(out, className, fields, table) &#125;&#125;<span class="hljs-keyword">def</span> generate(out, className, fields, table) &#123;    out.println <span class="hljs-string">&quot;package $packageName&quot;</span>    out.println <span class="hljs-string">&quot;&quot;</span>    Set types = <span class="hljs-keyword">new</span> HashSet()    fields.each() &#123;        types.add(it.type)    &#125;    <span class="hljs-comment">// In the order of IDEA formatting</span>    <span class="hljs-keyword">if</span> (primaryKeyAutoGenerated) &#123;        out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.IdType;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.TableField;&quot;</span>    <span class="hljs-keyword">if</span> (existsPrimaryKey) &#123;        out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.TableId;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.TableName;&quot;</span>    <span class="hljs-keyword">if</span> (types.contains(<span class="hljs-string">&quot;InputStream&quot;</span>)) &#123;        out.println <span class="hljs-string">&quot;import java.io.InputStream;&quot;</span>    &#125;    <span class="hljs-keyword">if</span> (types.contains(<span class="hljs-string">&quot;BigDecimal&quot;</span>)) &#123;        out.println <span class="hljs-string">&quot;import java.math.BigDecimal;&quot;</span>    &#125;    <span class="hljs-keyword">if</span> (types.contains(<span class="hljs-string">&quot;Date&quot;</span>)) &#123;        out.println <span class="hljs-string">&quot;import java.util.Date;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;import lombok.Getter;&quot;</span>    out.println <span class="hljs-string">&quot;import lombok.Setter;&quot;</span>    out.println <span class="hljs-string">&quot;import lombok.ToString;&quot;</span>    out.println <span class="hljs-string">&quot;&quot;</span>    out.println <span class="hljs-string">&quot;@Getter&quot;</span>    out.println <span class="hljs-string">&quot;@Setter&quot;</span>    out.println <span class="hljs-string">&quot;@ToString&quot;</span>    out.println <span class="hljs-string">&quot;@TableName(\&quot;&quot;</span> + table.getName() + <span class="hljs-string">&quot;\&quot;)&quot;</span>    out.print <span class="hljs-string">&quot;public class $className &#123;&quot;</span>    out.println <span class="hljs-string">&quot;&quot;</span>    fields.each &#123; it -&gt;        out.println <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-comment">// Print comments</span>        <span class="hljs-keyword">if</span> (isNotEmpty(it.comment)) &#123;            out.println <span class="hljs-string">&quot;    /**&quot;</span>            out.println <span class="hljs-string">&quot;     * $&#123;it.comment.toString()&#125;&quot;</span>            out.println <span class="hljs-string">&quot;     */&quot;</span>        &#125;        <span class="hljs-comment">// Print annotations</span>        it.annos.each &#123; anno -&gt;            out.println <span class="hljs-string">&quot;    $&#123;anno&#125;&quot;</span>        &#125;        out.println <span class="hljs-string">&quot;    private $&#123;it.type&#125; $&#123;it.name&#125;;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;&#125;&quot;</span>&#125;<span class="hljs-keyword">def</span> calcFields(table) &#123;    DasUtil.getColumns(table).reduce([]) &#123; fields, col -&gt;        <span class="hljs-keyword">def</span> spec = Case.LOWER.apply(col.getDataType().getSpecification())        <span class="hljs-keyword">def</span> typeStr = typeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value        <span class="hljs-keyword">def</span> annos = []        <span class="hljs-keyword">if</span> (DasUtil.isPrimary(col)) &#123;            existsPrimaryKey = <span class="hljs-literal">true</span>            <span class="hljs-keyword">if</span> (DasUtil.isAutoGenerated(col)) &#123;                primaryKeyAutoGenerated = <span class="hljs-literal">true</span>                annos += [<span class="hljs-string">&quot;@TableId(value = \&quot;&quot;</span> + col.getName() + <span class="hljs-string">&quot;\&quot;, type = IdType.AUTO)&quot;</span>]            &#125; <span class="hljs-keyword">else</span> &#123;                annos += [<span class="hljs-string">&quot;@TableId(\&quot;&quot;</span> + col.getName() + <span class="hljs-string">&quot;\&quot;)&quot;</span>]            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            annos += [<span class="hljs-string">&quot;@TableField(\&quot;&quot;</span> + col.getName() + <span class="hljs-string">&quot;\&quot;)&quot;</span>]        &#125;        fields += [[                           <span class="hljs-attr">name   :</span> javaName(col.getName(), <span class="hljs-literal">false</span>),                           <span class="hljs-attr">type   :</span> typeStr,                           <span class="hljs-attr">annos  :</span> annos,                           <span class="hljs-symbol">comment:</span> col.getComment()                   ]]    &#125;&#125;<span class="hljs-keyword">def</span> javaName(str, capitalize) &#123;    str = str.startsWith(<span class="hljs-string">&quot;is_&quot;</span>) ? str.substring(<span class="hljs-number">3</span>) : str    <span class="hljs-keyword">def</span> s = com.intellij.psi.codeStyle.NameUtil.splitNameIntoWords(str)            .collect &#123; Case.LOWER.apply(it).capitalize() &#125;            .join(<span class="hljs-string">&quot;&quot;</span>)            .replaceAll(<span class="hljs-regexp">/[^\p&#123;javaJavaIdentifierPart&#125;[_]]/</span>, <span class="hljs-string">&quot;_&quot;</span>)    capitalize || s.length() == <span class="hljs-number">1</span> ? s : Case.LOWER.apply(s[<span class="hljs-number">0</span>]) + s[<span class="hljs-number">1.</span>.<span class="hljs-number">-1</span>]&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> getPackageName(dir) &#123;    <span class="hljs-keyword">return</span> dir.toString()            .replaceAll(<span class="hljs-string">&quot;\\\\&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>)            .replaceAll(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>)            .replaceAll(<span class="hljs-string">&quot;^.*src(\\.main\\.java\\.)?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;;&quot;</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> isNotEmpty(content) &#123;    <span class="hljs-keyword">return</span> content != <span class="hljs-literal">null</span> &amp;&amp; content.toString().trim().length() &gt; <span class="hljs-number">0</span>&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;IDEA-连接数据库&quot;&gt;&lt;a href=&quot;#IDEA-连接数据库&quot; class=&quot;headerlink&quot; title=&quot;IDEA 连接数据库&quot;&gt;&lt;/a&gt;IDEA 连接数据库&lt;/h3&gt;&lt;p&gt;IDEA 内置了 DataGrip 的大部分功能用于管理数据库，可在侧边栏找</summary>
      
    
    
    
    <category term="IDEA" scheme="https://okayhu.github.io/blog/categories/IDEA/"/>
    
    
    <category term="idea" scheme="https://okayhu.github.io/blog/tags/idea/"/>
    
    <category term="groovy" scheme="https://okayhu.github.io/blog/tags/groovy/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Data-JPA 之自定义 Repository</title>
    <link href="https://okayhu.github.io/blog/posts/2022/spring-jpa-custom-repository/"/>
    <id>https://okayhu.github.io/blog/posts/2022/spring-jpa-custom-repository/</id>
    <published>2022-08-26T14:16:41.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<p>Spring-Data-JPA 提供许多常用的 Repository 接口，如 CrudRepository、PagingAndSortingRepository、JpaRepository 等。在实际开发中我们常常会有一些自定义方法，那我们应该如何扩展 Repository 接口呢？</p><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>首先定义一个 BaseRepository 继承 JpaRepository，并写下我们要扩展的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@NoRepositoryBean</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseRepository</span>&lt;T, ID&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;T, ID&gt; &#123;    List&lt;T&gt; <span class="hljs-title function_">findByIdIn</span><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIdIn</span><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span>;&#125;</code></pre></div><p>@NoRepositoryBean 的作用是通知 Spring 容器不要实例化 BaseRepository，因为 BaseRepository 是作为一个中间接口来派生具体的 Repository 接口。</p><p>接下来创建 BaseRepository 的实现类，实现扩展的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRepositoryImpl</span>&lt;T, ID&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleJpaRepository</span>&lt;T, ID&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseRepository</span>&lt;T, ID&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityManager em;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JpaEntityInformation&lt;T, ?&gt; entityInformation;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseRepositoryImpl</span><span class="hljs-params">(JpaEntityInformation&lt;T, ?&gt; entityInformation, EntityManager entityManager)</span> &#123;        <span class="hljs-built_in">super</span>(entityInformation, entityManager);        <span class="hljs-built_in">this</span>.em = entityManager;        <span class="hljs-built_in">this</span>.entityInformation = entityInformation;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title function_">findByIdIn</span><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span> &#123;        <span class="hljs-keyword">return</span> findAllById(ids);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(ID id)</span> &#123;        Assert.notNull(id, <span class="hljs-string">&quot;Id must not be null!&quot;</span>);        <span class="hljs-type">CriteriaBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> em.getCriteriaBuilder();        CriteriaDelete&lt;T&gt; delete = builder.createCriteriaDelete(getDomainClass());        Root&lt;T&gt; root = delete.from(getDomainClass());        delete.where(builder.equal(root.get(entityInformation.getIdAttribute()), id));        em.createQuery(delete).executeUpdate();    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIdIn</span><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span> &#123;        Assert.notNull(ids, <span class="hljs-string">&quot;Ids must not be null!&quot;</span>);        <span class="hljs-keyword">if</span> (ids.iterator().hasNext()) &#123;            <span class="hljs-type">CriteriaBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> em.getCriteriaBuilder();            CriteriaDelete&lt;T&gt; delete = builder.createCriteriaDelete(getDomainClass());            Root&lt;T&gt; root = delete.from(getDomainClass());            delete.where(getIdsPredicate(builder, root, ids));            em.createQuery(delete).executeUpdate();        &#125;    &#125;    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="hljs-keyword">protected</span> Predicate <span class="hljs-title function_">getIdsPredicate</span><span class="hljs-params">(CriteriaBuilder builder, Root&lt;T&gt; root, Iterable&lt;ID&gt; ids)</span> &#123;        Path&lt;ID&gt; path = (Path&lt;ID&gt;) root.get(entityInformation.getIdAttribute());        CriteriaBuilder.In&lt;ID&gt; inPredicate = builder.in(path);        ids.forEach(inPredicate::value);        <span class="hljs-keyword">return</span> inPredicate;    &#125;&#125;</code></pre></div><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>最后我们可以通过 <code>@EnableJpaRepositories</code> 在主类上指定新的 repositoryBaseClass</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableJpaRepositories(repositoryBaseClass = BaseRepositoryImpl.class)</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaExamplesApplication</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(JpaExamplesApplication.class, args);    &#125;&#125;</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们的 Repository 接口就不再继承 JpaRepository 了，而是继承 BaseRepository</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserRepository</span>&lt;User, Long&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseRepository</span>&lt;User, Long&gt; &#123;&#125;</code></pre></div><p>接下来测试下我们自定义的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRepositoryTests</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserRepository userRepository;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIdIn_test</span><span class="hljs-params">()</span> &#123;userRepository.deleteByIdIn(Arrays.asList(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>));    &#125;&#125;</code></pre></div><p>开启 SQL 打印</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">spring.jpa.show-sql</span>=<span class="hljs-string">true</span></code></pre></div><p>控制台成功输出：<code>Hibernate: delete from user where id in (1 , 2)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring-Data-JPA 提供许多常用的 Repository 接口，如 CrudRepository、PagingAndSortingRepository、JpaRepository 等。在实际开发中我们常常会有一些自定义方法，那我们应该如何扩展 Repositor</summary>
      
    
    
    
    <category term="Spring" scheme="https://okayhu.github.io/blog/categories/Spring/"/>
    
    
    <category term="spring" scheme="https://okayhu.github.io/blog/tags/spring/"/>
    
    <category term="jpa" scheme="https://okayhu.github.io/blog/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 的整洁架构</title>
    <link href="https://okayhu.github.io/blog/posts/2022/spring-boot-clean-architecture/"/>
    <id>https://okayhu.github.io/blog/posts/2022/spring-boot-clean-architecture/</id>
    <published>2022-07-26T12:26:02.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://www.baeldung.com/spring-boot-clean-architecture">Clean Architecture with Spring Boot</a><br>作者：<a href="https://www.baeldung.com/author/gilvanornelas/">Gilvan Ornelas</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们在开发长期的系统时，我们应该期待一个易变的环境。</p><p>一般来说，我们的功能需求、框架、I&#x2F;O 设备，甚至我们的代码设计都可能因为各种原因而改变。考虑到这一点，架构整洁之道（Clean Architecture）是一个高可维护代码的准则，考虑到我们周围所有的不确定性。</p><p>在这篇文章中，我们将按照 <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Robert C. Martin 的架构整洁之道</a> 创建一个用户注册 API 的例子。我们将使用他的原始层-实体、用例、接口适配器和框架&#x2F;驱动。</p><h2 id="整洁架构概述"><a href="#整洁架构概述" class="headerlink" title="整洁架构概述"></a>整洁架构概述</h2><p>整洁架构汇编了许多代码设计和原则，如 <a href="https://www.baeldung.com/solid-principles">SOLID</a>，<a href="https://wiki.c2.com/?StableAbstractionsPrinciple">稳定的抽象</a>，以及其他。但是，<strong>核心思想是根据业务价值对系统进行层次划分</strong>。因此，最高级别具有业务规则，每个较低级别都更接近 I&#x2F;O 设备。</p><p>此外，我们还可以将级别转化为层。在这种情况下，情况恰恰相反。内层等同于最高层，以此类推。</p><p><img src="https://www.baeldung.com/wp-content/uploads/2021/01/user-clean-architecture-layers-1.png"></p><p>考虑到这一点，<strong>我们可以根据我们的业务需要拥有尽可能多的级别。但是，要始终考虑到依赖性规则：一个较高的级别绝不能取决于一个较低的级别。</strong></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>让我们开始为我们的用户注册 API 定义系统规则。首先，业务规则：</p><ul><li>用户的密码必须有五个以上的字符。</li></ul><p>其次，我们有应用规则。它们可以以不同的形式出现，如用例或故事。我们将使用一个讲故事的短语。</p><ul><li>系统收到用户名和密码，验证该用户是否存在，并将新用户和创建时间一起保存下来。</li></ul><p><strong>请注意，这里没有提到任何数据库、用户界面或类似的东西。因为我们的业务并不关心这些细节</strong>，我们的代码也不应该关心。</p><h2 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h2><p>正如简洁的架构所建议的，让我们从我们的业务规则开始。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">passwordIsValid</span><span class="hljs-params">()</span>;    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;    String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>此外，还有一个 UserFactory：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserFactory</span> &#123;    User <span class="hljs-title function_">create</span><span class="hljs-params">(String name, String password)</span>;&#125;</code></pre></div><p>我们创建一个用户工厂方法是出于两个原因。为了适应稳定的抽象原则和隔离用户的创建。</p><p>接下来，让我们来实现这两点：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">User</span> &#123;    String name;    String password;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">passwordIsValid</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> password != <span class="hljs-literal">null</span> &amp;&amp; password.length() &gt; <span class="hljs-number">5</span>;    &#125;    <span class="hljs-comment">// Constructor and getters</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonUserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserFactory</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">create</span><span class="hljs-params">(String name, String password)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonUser</span>(name, password);    &#125;&#125;</code></pre></div><p><strong>如果我们有一个复杂的业务，那么我们应该尽可能清晰地构建我们的领域代码</strong>。所以，这一层是应用<a href="https://www.baeldung.com/design-patterns-series">设计模式</a>的好地方。特别是，应该考虑到<a href="https://www.baeldung.com/java-modules-ddd-bounded-contexts">领域驱动的设计</a>。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>现在，让我们测试一下我们的 CommonUser：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">given123Password_whenPasswordIsNotValid_thenIsFalse</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonUser</span>(<span class="hljs-string">&quot;Baeldung&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);    assertThat(user.passwordIsValid()).isFalse();&#125;</code></pre></div><p>我们可以看到，单元测试是非常清晰的。毕竟，没有 mocks 是这一层的一个好信号。<br>一般来说，如果我们在这里开始考虑 mocks，也许我们就把我们的实体和我们的用例混在一起了。</p><h2 id="用例层"><a href="#用例层" class="headerlink" title="用例层"></a>用例层</h2><p>用例是与我们系统的自动化有关的规则。在架构整洁之道中，我们称它们为交互器（Interactors）。</p><h3 id="用户注册交互器-UserRegisterInteractor"><a href="#用户注册交互器-UserRegisterInteractor" class="headerlink" title="用户注册交互器(UserRegisterInteractor)"></a>用户注册交互器(UserRegisterInteractor)</h3><p>首先，我们将建立我们的 UserRegisterInteractor，这样我们就可以知道我们要做的事情。然后，我们将创建并讨论所有使用的部分：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRegisterInteractor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserInputBoundary</span> &#123;    <span class="hljs-keyword">final</span> UserRegisterDsGateway userDsGateway;    <span class="hljs-keyword">final</span> UserPresenter userPresenter;    <span class="hljs-keyword">final</span> UserFactory userFactory;    <span class="hljs-comment">// Constructor</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> UserResponseModel <span class="hljs-title function_">create</span><span class="hljs-params">(UserRequestModel requestModel)</span> &#123;        <span class="hljs-keyword">if</span> (userDsGateway.existsByName(requestModel.getName())) &#123;            <span class="hljs-keyword">return</span> userPresenter.prepareFailView(<span class="hljs-string">&quot;User already exists.&quot;</span>);        &#125;        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userFactory.create(requestModel.getName(), requestModel.getPassword());        <span class="hljs-keyword">if</span> (!user.passwordIsValid()) &#123;            <span class="hljs-keyword">return</span> userPresenter.prepareFailView(<span class="hljs-string">&quot;User password must have more than 5 characters.&quot;</span>);        &#125;        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();        <span class="hljs-type">UserDsRequestModel</span> <span class="hljs-variable">userDsModel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDsRequestModel</span>(user.getName(), user.getPassword(), now);        userDsGateway.save(userDsModel);        <span class="hljs-type">UserResponseModel</span> <span class="hljs-variable">accountResponseModel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserResponseModel</span>(user.getName(), now.toString());        <span class="hljs-keyword">return</span> userPresenter.prepareSuccessView(accountResponseModel);    &#125;&#125;</code></pre></div><p>正如我们所见，我们正在执行所有用例步骤。另外，这一层还负责控制实体的舞蹈。尽管如此，我们仍然没有对用户界面或数据库的工作方式做出任何假设。但是，我们正在使用 UserDsGateway 和 UserPresenter。那么，我们怎么能不知道它们呢？因为，与 UserInputBoundary 一起，这些是我们的输入和输出边界。</p><h3 id="输入和输出边界"><a href="#输入和输出边界" class="headerlink" title="输入和输出边界"></a>输入和输出边界</h3><p>边界是定义组件如何交互的契约。<strong>输入边界将我们的用例暴露给外层：</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInputBoundary</span> &#123;    UserResponseModel <span class="hljs-title function_">create</span><span class="hljs-params">(UserRequestModel requestModel)</span>;&#125;</code></pre></div><p>接下来，我们有我们的输出边界，用于利用外层。首先，让我们定义数据源网关。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserRegisterDsGateway</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsByName</span><span class="hljs-params">(String name)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(UserDsRequestModel requestModel)</span>;&#125;</code></pre></div><p>其次，视图呈现器：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserPresenter</span> &#123;    UserResponseModel <span class="hljs-title function_">prepareSuccessView</span><span class="hljs-params">(UserResponseModel user)</span>;    UserResponseModel <span class="hljs-title function_">prepareFailView</span><span class="hljs-params">(String error)</span>;&#125;</code></pre></div><p>注意：<strong>我们正在使用<a href="https://www.baeldung.com/java-dependency-inversion-principle">依赖性倒置原则</a>，使我们的业务不受数据库和 UI 等细节的影响</strong>。</p><h3 id="解耦模式"><a href="#解耦模式" class="headerlink" title="解耦模式"></a>解耦模式</h3><p>在继续之前，<strong>请注意边界是如何定义系统自然划分的契约</strong>。但我们还必须决定我们的应用程序将如何交付：</p><ul><li>单片 - 可能使用某些包结构进行组织</li><li>通过使用模块</li><li>通过使用服务&#x2F;微服务</li></ul><p>考虑到这一点，<strong>我们可以通过任何解耦模式达到干净的架构目标</strong>。因此，<strong>我们应该准备根据我们当前和未来的业务需求，在这些策略之间进行改变</strong>。在选择了我们的解耦模式后，代码的划分应该根据我们的边界来进行。</p><h3 id="请求和响应模型"><a href="#请求和响应模型" class="headerlink" title="请求和响应模型"></a>请求和响应模型</h3><p>到目前为止，我们已经使用接口创建了跨层的操作。接下来，让我们看看如何跨这些边界传输数据。</p><p>注意我们所有的边界是如何只处理<em>String</em>或<em>Model</em>对象的：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRequestModel</span> &#123;    String login;    String password;    <span class="hljs-comment">// Getters, setters, and constructors</span>&#125;</code></pre></div><p>基本上，<strong>只有简单的数据结构才能跨越边界</strong>。此外，所有模型都只有字段和访问器。另外，数据对象属于内侧。所以，我们可以保持依赖规则。</p><p>但是为什么我们有这么多相似的对象呢？当我们得到重复的代码时，它可能有两种类型：</p><ul><li>错误或意外重复。代码相似性是偶然的，因为每个对象都有不同的更改原因。如果我们试图删除它，我们将面临违反<a href="https://www.baeldung.com/java-single-responsibility-principle">单一责任原则</a>的风险。</li><li>真正的重复。代码出于同样的原因而改变。因此，我们应该删除它</li></ul><p>由于每个模型都有不同的职责，所以我们得到了这些对象。</p><h3 id="测试用户注册交互器"><a href="#测试用户注册交互器" class="headerlink" title="测试用户注册交互器"></a>测试用户注册交互器</h3><p>现在，让我们创建我们的单元测试：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">givenBaeldungUserAnd12345Password_whenCreate_thenSaveItAndPrepareSuccessView</span><span class="hljs-params">()</span> &#123;    given(userDsGateway.existsByIdentifier(<span class="hljs-string">&quot;identifier&quot;</span>))        .willReturn(<span class="hljs-literal">true</span>);    interactor.create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRequestModel</span>(<span class="hljs-string">&quot;baeldung&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>));    then(userDsGateway).should()        .save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDsRequestModel</span>(<span class="hljs-string">&quot;baeldung&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>, now()));    then(userPresenter).should()        .prepareSuccessView(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserResponseModel</span>(<span class="hljs-string">&quot;baeldung&quot;</span>, now()));&#125;</code></pre></div><p>正如我们所见，大多数用例测试都是关于控制实体和边界请求。而且，我们的界面允许我们轻松地模拟细节。</p><h2 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h2><p>至此，我们完成了所有业务。现在，让我们开始插入我们的详细信息。</p><p><strong>我们的业务应该只处理最方便的数据格式</strong>，我们的外部代理（如 DB 或 UI）也应如此。<strong>但是，这种格式通常是不同的</strong>。为此，<strong>接口适配器层负责数据的转换</strong>。</p><h3 id="使用-JPA-的-UserRegisterDsGateway"><a href="#使用-JPA-的-UserRegisterDsGateway" class="headerlink" title="使用 JPA 的 UserRegisterDsGateway"></a>使用 JPA 的 UserRegisterDsGateway</h3><p>首先，让我们使用<a href="https://www.baeldung.com/the-persistence-layer-with-spring-and-jpa">JPA</a>来映射我们的用户表：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table(name = &quot;user&quot;)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDataMapper</span> &#123;    <span class="hljs-meta">@Id</span>    String name;    String password;    LocalDateTime creationTime;    <span class="hljs-comment">//Getters, setters, and constructors</span>&#125;</code></pre></div><p>正如我们所见，Mapper 的目标是将我们的对象映射到数据库格式。</p><p>接下来，使用我们的<a href="https://www.baeldung.com/jpa-entities">实体的</a>JpaRepository：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">JpaUserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;UserDataMapper, String&gt; &#123;&#125;</code></pre></div><p>鉴于我们将使用 spring-boot，那么这就是保存用户所需的全部内容。</p><p>现在，是时候实现我们的 UserRegisterDsGateway 了：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserRegisterDsGateway</span> &#123;    <span class="hljs-keyword">final</span> JpaUserRepository repository;    <span class="hljs-comment">// Constructor</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsByName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-keyword">return</span> repository.existsById(name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(UserDsRequestModel requestModel)</span> &#123;        <span class="hljs-type">UserDataMapper</span> <span class="hljs-variable">accountDataMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDataMapper</span>(requestModel.getName(), requestModel.getPassword(), requestModel.getCreationTime());        repository.save(accountDataMapper);    &#125;&#125;</code></pre></div><p>在大多数情况下，代码不言自明。除了我们的方法，请注意 UserRegisterDsGateway 的名称。如果我们选择 UserDsGateway 代替，那么其他用户用例可能会违反<a href="https://www.baeldung.com/java-interface-segregation">接口隔离原则</a>。</p><h3 id="用户注册-API"><a href="#用户注册-API" class="headerlink" title="用户注册 API"></a>用户注册 API</h3><p>现在，让我们创建我们的 HTTP 适配器：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRegisterController</span> &#123;    <span class="hljs-keyword">final</span> UserInputBoundary userInput;    <span class="hljs-comment">// Constructor</span>    <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span>    UserResponseModel <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserRequestModel requestModel)</span> &#123;        <span class="hljs-keyword">return</span> userInput.create(requestModel);    &#125;&#125;</code></pre></div><p>正如我们所看到的，<strong>这里唯一的目标是接收请求并将响应发送</strong>给客户端。</p><h3 id="准备响应"><a href="#准备响应" class="headerlink" title="准备响应"></a>准备响应</h3><p>在回复之前，我们应该格式化我们的回复：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResponseFormatter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserPresenter</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> UserResponseModel <span class="hljs-title function_">prepareSuccessView</span><span class="hljs-params">(UserResponseModel response)</span> &#123;        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">responseTime</span> <span class="hljs-operator">=</span> LocalDateTime.parse(response.getCreationTime());        response.setCreationTime(responseTime.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;hh:mm:ss&quot;</span>)));        <span class="hljs-keyword">return</span> response;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> UserResponseModel <span class="hljs-title function_">prepareFailView</span><span class="hljs-params">(String error)</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseStatusException</span>(HttpStatus.CONFLICT, error);    &#125;&#125;</code></pre></div><p>我们的 UserRegisterInteractor 专注于创建用户。尽管如此，表示规则只涉及适配器内部。此外，<strong>凡是难以测试的东西，我们都应该把它分为可测试的对象和<a href="https://martinfowler.com/bliki/HumbleObject.html">不起眼的对象</a>。</strong> 因此，UserResponseFormatter 很容易让我们验证我们的表示规则：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">givenDateAnd3HourTime_whenPrepareSuccessView_thenReturnOnly3HourTime</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">UserResponseModel</span> <span class="hljs-variable">modelResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserResponseModel</span>(<span class="hljs-string">&quot;baeldung&quot;</span>, <span class="hljs-string">&quot;2020-12-20T03:00:00.000&quot;</span>);    <span class="hljs-type">UserResponseModel</span> <span class="hljs-variable">formattedResponse</span> <span class="hljs-operator">=</span> userResponseFormatter.prepareSuccessView(modelResponse);    assertThat(formattedResponse.getCreationTime()).isEqualTo(<span class="hljs-string">&quot;03:00:00&quot;</span>);&#125;</code></pre></div><p>正如我们所见，我们在将其发送到视图之前测试了所有逻辑。因此，<strong>只有不起眼的对象在不太可测试的部分</strong>。</p><h2 id="驱动程序和框架"><a href="#驱动程序和框架" class="headerlink" title="驱动程序和框架"></a>驱动程序和框架</h2><p>事实上，我们通常不在这里编码。那是因为这一层<strong>代表了与外部代理的最低级别的连接</strong>。例如，用于连接数据库或 web 框架的 H2 驱动程序。在这种情况下，<strong>我们将使用<a href="https://www.baeldung.com/spring-boot">spring-boot</a>作为<a href="https://www.baeldung.com/bootstraping-a-web-application-with-spring-and-java-based-configuration">web</a>和<a href="https://www.baeldung.com/spring-dependency-injection">依赖注入</a>框架</strong>。所以，我们需要它的启动点：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CleanArchitectureApplication</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      SpringApplication.run(CleanArchitectureApplication.class);    &#125;&#125;</code></pre></div><p>到目前为止，<strong>我们的业务中还没有使用任何</strong> <strong><a href="https://www.baeldung.com/spring-bean-annotations">Spring 注解</a><strong>。除了 spring-specifics 适配器之外，作为我们的 UserRegisterController。</strong>这是因为我们应该将 spring-boot 视为任何其他细节</strong>。</p><h2 id="可怕的主类"><a href="#可怕的主类" class="headerlink" title="可怕的主类"></a>可怕的主类</h2><p>终于，最后一块了！</p><p>到目前为止，我们遵循了<a href="https://wiki.c2.com/?StableAbstractionsPrinciple">稳定抽象原则</a>。此外，我们通过<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">控制反转</a>保护我们的内层免受外部代理的影响。最后，我们将所有对象的创建与使用分开。此时，由我们来<strong>创建剩余的依赖项并将它们注入到我们的项目中</strong>：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>BeanFactoryPostProcessor <span class="hljs-title function_">beanFactoryPostProcessor</span><span class="hljs-params">(ApplicationContext beanRegistry)</span> &#123;    <span class="hljs-keyword">return</span> beanFactory -&gt; &#123;        genericApplicationContext(          (BeanDefinitionRegistry) ((AnnotationConfigServletWebServerApplicationContext) beanRegistry)            .getBeanFactory());    &#125;;&#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">genericApplicationContext</span><span class="hljs-params">(BeanDefinitionRegistry beanRegistry)</span> &#123;    <span class="hljs-type">ClassPathBeanDefinitionScanner</span> <span class="hljs-variable">beanDefinitionScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(beanRegistry);    beanDefinitionScanner.addIncludeFilter(removeModelAndEntitiesFilter());    beanDefinitionScanner.scan(<span class="hljs-string">&quot;com.baeldung.pattern.cleanarchitecture&quot;</span>);&#125;<span class="hljs-keyword">static</span> TypeFilter <span class="hljs-title function_">removeModelAndEntitiesFilter</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> (MetadataReader mr, MetadataReaderFactory mrf) -&gt; !mr.getClassMetadata()      .getClassName()      .endsWith(<span class="hljs-string">&quot;Model&quot;</span>);&#125;</code></pre></div><p>在我们的例子中，我们使用 spring-boot <a href="https://www.baeldung.com/spring-dependency-injection">依赖注入</a>来创建我们所有的实例。由于我们没有使用<a href="https://www.baeldung.com/spring-bean-annotations#component">@Component</a>，我们正在扫描我们的根包并仅忽略 Model objects 。</p><p>尽管这种策略看起来可能更复杂，但它使我们的业务与 DI 框架分离。另一方面，<strong>主类控制了我们所有的系统</strong>。这就是为什么干净的架构将它视为一个包含所有其他层的特殊层：</p><p><img src="https://www.baeldung.com/wp-content/uploads/2021/01/user-clean-architecture-layers.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们了解了 Bob 大叔的 <strong>整洁架构是如何建立在许多设计模式和原则之上的</strong>。此外，我们创建了一个使用 Spring Boot 应用它的用例。</p><p>尽管如此，我们还是把一些原则放在一边。但是，他们都朝着同一个方向前进。我们可以通过引用它的创建者来总结它：“一个好的架构师<strong>必须最大化未做出的决定的数量</strong>。”我们通过<strong>使用边界保护我们的业务代码免受细节</strong>影响来做到这一点。</p><p>像往常一样，完整的代码可以 <a href="https://github.com/eugenp/tutorials/tree/master/patterns/clean-architecture">在 GitHub 上找到</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://www.baeldung.com/spring-boot-clean-architecture&quot;&gt;Clean Architecture with Spring Boot&lt;/a&gt;&lt;br&gt;作者：&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Spring" scheme="https://okayhu.github.io/blog/categories/Spring/"/>
    
    
    <category term="spring" scheme="https://okayhu.github.io/blog/tags/spring/"/>
    
    <category term="springboot" scheme="https://okayhu.github.io/blog/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之 对象引用与垃圾回收算法</title>
    <link href="https://okayhu.github.io/blog/posts/2022/jvm-object-gc/"/>
    <id>https://okayhu.github.io/blog/posts/2022/jvm-object-gc/</id>
    <published>2022-07-18T14:08:11.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h2><p><strong>强引用</strong>：我们平时 new 了一个对象就是强引用，例如 <code>Object obj = new Object()</code>。即使在内存不足的情况下，JVM 宁愿抛出 OutOfMemory 错误也不会回收这种对象。</p><!--truncate--><p><strong>软引用</strong>：如果一个对象只具有软引用，则内存空间足够，垃圾回收器不会回收它，如果内存不足，则在发生内存溢出之前被回收。</p><div class="code-wrapper"><pre><code class="hljs java">SoftReference&lt;String&gt; softRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;String&gt;(str);</code></pre></div><p><strong>弱引用</strong>：具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器进行垃圾回收时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><div class="code-wrapper"><pre><code class="hljs java">WeakReference&lt;String&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;String&gt;(str);</code></pre></div><p><strong>虚引用</strong>：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<span class="hljs-type">PhantomReference</span> <span class="hljs-variable">phantomRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>(str, queue);</code></pre></div><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>没有任何引用的对象。</p><h2 id="如何判断对象没有任何引用"><a href="#如何判断对象没有任何引用" class="headerlink" title="如何判断对象没有任何引用"></a>如何判断对象没有任何引用</h2><h3 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h3><p>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。</p><div class="note note-info">            <p>引用计数器无法解决循环应用的问题。</p>          </div><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>从 GC Roots 开始向下搜索，搜索所走过的路径称为 <code>引用链（Reference Chain）</code>。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p><p>作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：</p><ul><li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等</strong>。</li><li><strong>方法区中类静态属性引用的对象、java 类的引用类型静态变量</strong>。</li><li><strong>方法区中常量引用的对象。比如：字符串常量池里的引用</strong>。</li><li><strong>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</strong>。</li><li>JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。</li><li>所有被同步锁（synchronized 关键字）持有的对象。</li><li>JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li><li>JVM 实现中的临时性对象，跨代引用的对象。</li></ul><p>以上的回收都是对象，类（Class）的回收条件非常苛刻，必须同时满足以下的条件（仅仅是可以，不代表必然，因为还有一些参数可以进行控制）</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p><code>-Xnoclassgc</code>：禁用类的垃圾回收。</p><p>废弃的常量和静态变量的回收其实就和 Class 回收的条件差不多。</p><p><strong>Finalize</strong></p><p>Object 类中的 finalize() 方法类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用 finalize()。</p><div class="note note-info">            <p>当一个对象可被回收时，如果执行该对象的 finalize() 方法，只能说<strong>有可能</strong>通过在该方法中让对象重新被引用，从而实现自救。</p>          </div><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>复制回收算法适合于新生代。因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高。</p><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>算法分为标记和清除两个阶段。首先扫描出所有对象并标记出需要回收的对象，在标记完成后扫描回收所有被标记的对象，所以需要扫描两遍。回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，对比复制回收效率要低，所以标记清除算法适用于老年代。</p><p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>算法分为标记和整理两个阶段：首先标记出所有需要回收的对象，在标记完成后，不是直接对可回收对象进行清理，而是将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。</p><p>标记整理算法虽然没有内存碎片，但是效率偏低。我们看到标记整理算法与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用对象的地方都需要更新（直接指针需要调整）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引用的分类&quot;&gt;&lt;a href=&quot;#引用的分类&quot; class=&quot;headerlink&quot; title=&quot;引用的分类&quot;&gt;&lt;/a&gt;引用的分类&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;强引用&lt;/strong&gt;：我们平时 new 了一个对象就是强引用，例如 &lt;code&gt;Object o</summary>
      
    
    
    
    <category term="Java" scheme="https://okayhu.github.io/blog/categories/Java/"/>
    
    
    <category term="jvm" scheme="https://okayhu.github.io/blog/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>MapStruct 的使用姿势</title>
    <link href="https://okayhu.github.io/blog/posts/2022/mapstrcut-style/"/>
    <id>https://okayhu.github.io/blog/posts/2022/mapstrcut-style/</id>
    <published>2022-07-14T14:03:31.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<p>在我们的项目开发过程中，MapStruct 作为一款 pojo 转换工具无疑是十分强大的，便捷的。<br>但是 MapStruct 虽好，也存在着一些使用误区。</p><h3 id="不要改变源-pojo-的属性"><a href="#不要改变源-pojo-的属性" class="headerlink" title="不要改变源 pojo 的属性"></a>不要改变源 pojo 的属性</h3><p>e.g. 将 UserDTO 对象转换为 UserVO</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDTO</span> &#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> Integer age;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVO</span> &#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> List&lt;RoleVO&gt; roles;    <span class="hljs-keyword">private</span> List&lt;GroupVO&gt; groups;    <span class="hljs-keyword">private</span> List&lt;String&gt; authorityCodes;&#125;<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;    UserVO <span class="hljs-title function_">dtoToVo</span><span class="hljs-params">(UserDTO userDto)</span>;    <span class="hljs-meta">@BeforeMapping</span>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterDtoToVo</span><span class="hljs-params">(UserDTO userDto)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Administrator&quot;</span>.equals(userDto.getUsername())) &#123;            userDto.setId(<span class="hljs-number">0L</span>);            userDto.setAge(<span class="hljs-literal">null</span>);        &#125;    &#125;&#125;</code></pre></div><p>问题：对于方法的调用者来说，会造成预期之外的异常。</p><h3 id="在-Mapper-中不要包含大量的业务逻辑"><a href="#在-Mapper-中不要包含大量的业务逻辑" class="headerlink" title="在 Mapper 中不要包含大量的业务逻辑"></a>在 Mapper 中不要包含大量的业务逻辑</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;    UserVO <span class="hljs-title function_">dtoToVo</span><span class="hljs-params">(UserDTO userDto)</span>;    <span class="hljs-meta">@AfterMapping</span>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterDtoToVo</span><span class="hljs-params">(<span class="hljs-meta">@MappingTarget</span> UserVO userVo)</span> &#123;        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> SpringContextUtil.getBean(UserService.class);        userVo.setAuthorityCodes(userService.getAllAuthorityCodes(userVo.getId()));    &#125;&#125;</code></pre></div><p>问题：</p><ul><li>Mapper 中的方法，很大程度会被多次调用，应用在不同的领域，所以编写者需要确保方法的预期是通用的、可信任的。而在上述写法中，转换后的 UserVO 不包含 roles、groups 包含 authorityCodes，但是这对于方法调用者来说不一定是符合预期的。</li><li>一旦修改 Mapper 中的业务逻辑，可能会对多处造成不好的影响。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们的项目开发过程中，MapStruct 作为一款 pojo 转换工具无疑是十分强大的，便捷的。&lt;br&gt;但是 MapStruct 虽好，也存在着一些使用误区。&lt;/p&gt;
&lt;h3 id=&quot;不要改变源-pojo-的属性&quot;&gt;&lt;a href=&quot;#不要改变源-pojo-的属性&quot; cl</summary>
      
    
    
    
    <category term="Tool" scheme="https://okayhu.github.io/blog/categories/Tool/"/>
    
    
    <category term="tool" scheme="https://okayhu.github.io/blog/tags/tool/"/>
    
    <category term="mapstruct" scheme="https://okayhu.github.io/blog/tags/mapstruct/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之对象的创建过程和内存布局</title>
    <link href="https://okayhu.github.io/blog/posts/2022/jvm-object-memory/"/>
    <id>https://okayhu.github.io/blog/posts/2022/jvm-object-memory/</id>
    <published>2022-07-04T07:34:20.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><p><img src="https://uposs.justokay.cn/images/jvm/jvm-object-memory-01.png"></p><h3 id="检查加载"><a href="#检查加载" class="headerlink" title="检查加载"></a>检查加载</h3><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（符号引用 ：符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、 解析和初始化过。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p><p>分配内存由两种方式：</p><ul><li><strong>指针碰撞</strong>：如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞。</li><li><strong>空闲列表</strong>：如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的。在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为空闲列表。</li></ul><div class="note note-info">            <p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是 Serial、ParNew 等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。如果是使用 CMS 这种不带压缩整理的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>          </div><p>JVM 在分配内存时，还要考虑并发安全问题，解决这个问题有两种方案:</p><ul><li><code>CAS</code>: 对分配内存空间的动作进行同步处理，实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li><li><code>TLAB（Thread Local Allocation Buffer, 本地线程分配缓冲）</code>：</li><li><ul><li>概述：是指把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（TLAB）。</li><li>步骤：JVM 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用。</li><li>参数：<code>JVM options: -XX:+UseTLAB </code> 允许在年轻代空间中使用线程本地分配块（TLAB），默认启用，如果要禁用 TLAB，请指定 <code>-XX:-UseTLAB</code>。</li></ul></li></ul><h3 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h3><p>注意不是构造方法,内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（如 int 值为 0，boolean 值为 false 等）。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java Classes 在 Java hotspot VM 内部表示为类元数据）、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。</p><h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化（执行 <code>init</code> 方法），这样一个真正可用的对象才算完全产生出来。</p><h2 id="对象的内存分配策略"><a href="#对象的内存分配策略" class="headerlink" title="对象的内存分配策略"></a>对象的内存分配策略</h2><p>对象的内存分配通常是在 Java 堆上分配，但随着虚拟机优化技术的诞生（<code>逃逸分析技术</code>），某些场景下也会在栈上分配。对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。</p><p>总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种普遍的规则：</p><ul><li><strong>对象优先分配在 Eden 区</strong>，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC。</li><li><strong>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）</strong>。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li><li><strong>长期存活的对象进入老年代</strong>。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC，那么对象会进入 Survivor 区，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1，当它的年龄增加到一定程度（<strong>并发的垃圾回收器默认为 15，CMS 是 6</strong>），就会被晋升到老年代中。可以通过 <code>-XX:MaxTenuringThreshold</code> 调整。</li><li><strong>动态判断对象的年龄</strong>。为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</li><li><strong>空间分配担保</strong>。每次进行 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败。如 <code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；如果小于或者 <code>HandlePromotionFailure=false</code>，则改为进行一次 Full GC。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="https://uposs.justokay.cn/images/jvm/jvm-object-memory-02.png"></p><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h3 id="对象头（Object-Header）"><a href="#对象头（Object-Header）" class="headerlink" title="对象头（Object Header）"></a>对象头（Object Header）</h3><p>对象头在 HotSpot 虚拟机中被分为了两部分，一部分称为 Mark Word，另一部分是类型指针。如果对象是一个数组，那在对象头中还有一块用于记录数组长度的数据。</p><table><thead><tr><th align="center">长度</th><th align="center">内容</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">32&#x2F;64bit</td><td align="center">Mark Word</td><td align="center">存储对象的 hashcode 、偏向锁模式、锁信息和 GC 分代年龄</td></tr><tr><td align="center">32&#x2F;64bit</td><td align="center">Class Metadata Address</td><td align="center">存储对象指向它的类元数据的指针</td></tr><tr><td align="center">32&#x2F;64bit</td><td align="center">Array Length</td><td align="center">数组长度（不一定有）</td></tr></tbody></table><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><p>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的对象的属性等信息。</p><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对对象的大小必须是 <strong>8 字节的整数倍</strong>，当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java 程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有句柄和直接指针两种方式。</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>指向对象，代表一个对象在内存中的起始地址。如果使用直接指针访问，引用中存储的直接就是对象地址，那么 Java 堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</p><p><img src="https://uposs.justokay.cn/images/jvm/jvm-object-memory-03.png"></p><p>优点：速度快，节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。如果使用直接句柄访问，Java 堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><img src="https://uposs.justokay.cn/images/jvm/jvm-object-memory-04.png"></p><p>优点：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象的创建过程&quot;&gt;&lt;a href=&quot;#对象的创建过程&quot; class=&quot;headerlink&quot; title=&quot;对象的创建过程&quot;&gt;&lt;/a&gt;对象的创建过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://uposs.justokay.cn/images/jvm/jvm</summary>
      
    
    
    
    <category term="Java" scheme="https://okayhu.github.io/blog/categories/Java/"/>
    
    
    <category term="jvm" scheme="https://okayhu.github.io/blog/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>使用 Firewalld 保护 Docker 安全</title>
    <link href="https://okayhu.github.io/blog/posts/2022/docker-firewalld/"/>
    <id>https://okayhu.github.io/blog/posts/2022/docker-firewalld/</id>
    <published>2022-06-30T11:47:12.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 防火墙使用的是底层的 iptables，firewalld 默认不生效。</p><p>如果想要使用 firewalld，需要做以下调整：</p><h3 id="重新构建-DOCKER-USER-chain"><a href="#重新构建-DOCKER-USER-chain" class="headerlink" title="重新构建 DOCKER-USER chain"></a>重新构建 <code>DOCKER-USER chain</code></h3><p>即使 DOCKER-USER 已存在，也需要删除后重建</p><div class="code-wrapper"><pre><code class="hljs bash">firewall-cmd --permanent --direct --remove-chain ipv4 filter DOCKER-USERfirewall-cmd --permanent --direct --remove-rules ipv4 filter DOCKER-USERfirewall-cmd --permanent --direct --add-chain ipv4 filter DOCKER-USER</code></pre></div><h3 id="添加-iptables-规则"><a href="#添加-iptables-规则" class="headerlink" title="添加 iptables 规则"></a>添加 iptables 规则</h3><div class="code-wrapper"><pre><code class="hljs bash">firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 0 -i docker0 -j ACCEPT -m comment --comment <span class="hljs-string">&quot;allows incoming from docker&quot;</span>firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 0 -i docker0 -o eth0 -j ACCEPT -m comment --comment <span class="hljs-string">&quot;allows docker to eth0&quot;</span>firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT -m comment --comment <span class="hljs-string">&quot;allows docker containers to connect to the outside world&quot;</span>firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 0 -j RETURN -s 172.17.0.0/16 -m comment --comment <span class="hljs-string">&quot;allow internal docker communication&quot;</span></code></pre></div><h3 id="添加自定义的规则"><a href="#添加自定义的规则" class="headerlink" title="添加自定义的规则"></a>添加自定义的规则</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 允许指定 ip 流量通过, 将 1.1.1.1 替换成你需要通过的 ip</span>firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 0 -s 1.1.1.1/32 -j ACCEPT<span class="hljs-comment"># 允许指定 ip 访问指定的端口（示例）</span>firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 0 -p tcp -m multiport --dports 80,443 -s 1.1.1.1/32 -j ACCEPT <span class="hljs-comment"># 你也可以指定端口，這裡僅為示例</span><span class="hljs-comment"># 拒绝其他流量</span>firewall-cmd --permanent --direct --add-rule ipv4 filter DOCKER-USER 10 -j REJECT --reject-with icmp-host-unreachable -m comment --comment <span class="hljs-string">&quot;reject all other traffic&quot;</span></code></pre></div><div class="note note-warn">            <ul><li><code>REJECT</code>规则要在最后执行</li><li>同一条规则不要写多个 IP 地址</li><li>如果在 Docker 运行时重启 firewalld，那么 firewalld 将删除 DOCKER-USER</li></ul>          </div><h3 id="重新加载配置并验证"><a href="#重新加载配置并验证" class="headerlink" title="重新加载配置并验证"></a>重新加载配置并验证</h3><ul><li>重新加载配置：<code>firewall-cmd --reload</code></li><li>验证：<code>iptables -L</code> 查看 DOCKER-USER 的配置，或者通过 <code>cat /etc/firewalld/direct.xml</code> 查看 direct 的配置。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker 防火墙使用的是底层的 iptables，firewalld 默认不生效。&lt;/p&gt;
&lt;p&gt;如果想要使用 firewalld，需要做以下调整：&lt;/p&gt;
&lt;h3 id=&quot;重新构建-DOCKER-USER-chain&quot;&gt;&lt;a href=&quot;#重新构建-DOCKER-US</summary>
      
    
    
    
    <category term="Devops" scheme="https://okayhu.github.io/blog/categories/Devops/"/>
    
    
    <category term="docker" scheme="https://okayhu.github.io/blog/tags/docker/"/>
    
    <category term="firewalld" scheme="https://okayhu.github.io/blog/tags/firewalld/"/>
    
  </entry>
  
  <entry>
    <title>更换 Linux 服务器 ssh 默认端口</title>
    <link href="https://okayhu.github.io/blog/posts/2022/linux-ssh-port-update/"/>
    <id>https://okayhu.github.io/blog/posts/2022/linux-ssh-port-update/</id>
    <published>2022-06-27T01:54:58.000Z</published>
    <updated>2023-01-07T12:38:04.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>环境 centos 7</p></blockquote><h3 id="备份-ssh-配置文件"><a href="#备份-ssh-配置文件" class="headerlink" title="备份 ssh 配置文件"></a>备份 ssh 配置文件</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.bak</code></pre></div><h3 id="修改默认端口"><a href="#修改默认端口" class="headerlink" title="修改默认端口"></a>修改默认端口</h3><div class="code-wrapper"><pre><code class="hljs bash">vi etc/ssh/sshd_config</code></pre></div><p>修改 <code>#Port 22</code> 为 <code>Port 2233</code>，则 ssh 端口分改为 2233</p><h3 id="重启-sshd-服务"><a href="#重启-sshd-服务" class="headerlink" title="重启 sshd 服务"></a>重启 sshd 服务</h3><div class="code-wrapper"><pre><code class="hljs bash">systemctl restart sshd</code></pre></div><h2 id="放行新的端口"><a href="#放行新的端口" class="headerlink" title="放行新的端口"></a>放行新的端口</h2><div class="code-wrapper"><pre><code class="hljs bash">firewall-cmd --premanent --add-port=2233/tcpfirewall-cmd --reload</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;环境 centos 7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;备份-ssh-配置文件&quot;&gt;&lt;a href=&quot;#备份-ssh-配置文件&quot; class=&quot;headerlink&quot; title=&quot;备份 ssh 配置文件&quot;&gt;&lt;/a&gt;备份 ssh </summary>
      
    
    
    
    <category term="Devops" scheme="https://okayhu.github.io/blog/categories/Devops/"/>
    
    
    <category term="linux" scheme="https://okayhu.github.io/blog/tags/linux/"/>
    
    <category term="ssh" scheme="https://okayhu.github.io/blog/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之内存结构</title>
    <link href="https://okayhu.github.io/blog/posts/2022/jvm-memory-structure/"/>
    <id>https://okayhu.github.io/blog/posts/2022/jvm-memory-structure/</id>
    <published>2022-06-22T13:47:45.000Z</published>
    <updated>2023-01-07T12:38:04.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java Virtual Machine（JVM）是一种抽象的计算机，基于堆栈架构，它有自己的指令集和内存管理。它加载 class 文件、分析、解释并执行字节码。基本结构如下：</p><p><img src="https://uposs.justokay.cn/images/jvm/jvm-memory-structure-01.png"></p><p>Java 虚拟机会在执行 Java 程序的过程中把它所管理的内存划分为若干区域。如图：</p><p><img src="https://uposs.justokay.cn/images/jvm/jvm-memory-structure-02.png"></p><p>JVM 内存结构主要分为三大块：堆、栈和方法区。堆是 JVM 中最大的一块区域，由年轻代和老年代组成，而年轻代内存又分成两部分，Eden 区和 Survivor 区，而 Survivor 区又分为 From 区、To 区，默认情况下年轻代按照 8:1:1 的比例来分配。</p><p>通过一张图来了解如何通过参数来控制各区域的内存大小：</p><p><img src="https://uposs.justokay.cn/images/jvm/jvm-memory-structure-03.png"></p><ul><li><code>Xms</code>：设置堆的最小空间大小。</li><li><code>Xmx</code>：设置堆的最大空间大小。</li><li><code>XX:NewSize</code>：设置新生代最小空间大小。</li><li><code>XX:MaxNewSize</code>：设置新生代最大空间大小。</li><li><code>XX:PermSize</code>：设置永久代最小空间大小。</li><li><code>XX:MaxPermSize</code>：设置永久代最大空间大小。</li><li><code>Xss</code>：设置每个线程的堆栈大小。</li></ul><div class="note note-info">            <p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。（老年代空间大小 &#x3D; 堆空间大小 - 年轻代空间大小）</p>          </div><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>对于大多数应用来说，堆（Heap）是 Java 虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>堆是垃圾收集器管理的主要区域。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以堆中还可以细分为：新生代和老年代。当让再细分的话还要，Eden 区、From Survivor 区、To Survivor 区。</p><p>根据 Java 虚拟机规范的规定，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区（Method Area）与堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>对于习惯在 HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为 永久代（Permanent Generation），本质上两者并不等价。仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java 虚拟机规范对这个区域的限制非常宽松，除了和堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><div class="note note-info">            <p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样永久存在了。</p>          </div><p>根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p><h2 id="程序计数器（The-pc-Register）"><a href="#程序计数器（The-pc-Register）" class="headerlink" title="程序计数器（The pc Register）"></a>程序计数器（The pc Register）</h2><p>程序计数器是线程私有的，它可以看作当前线程所执行的字节码的行号指示器。</p><p>在字节码解释器工作的时候就是通过改变程序计数器的值来选取和记录下一条要执行的字节码指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都要依赖其完成。</p><ul><li>如果线程正在执行一个 Java 方法，那么程序计数器记录的是正在执行的虚拟机字节码指令的地址。</li><li>如果正在执行的是一个本地（Native）方法，则计数器值为空（Undefined）。</li></ul><div class="note note-info">            <p>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>          </div><h2 id="虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="虚拟机栈（Java Virtual Machine Stacks）"></a>虚拟机栈（Java Virtual Machine Stacks）</h2><p>每个线程都有一个私有 Java 虚拟机栈，与该线程同时创建，同时销毁。它保存局部变量和部分结果，并在方法调用和返回中起作用。Java 虚拟机堆栈的内存不必是连续的。</p><p>Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：每一个方法在执行的同时都会创建一个栈帧（Frames），用于存储 局部变量表、操作数栈、动态链接、方法出口 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程。</p><ul><li>每个方法对应一个栈帧</li><li>栈的数据结构是先进后出（FILO）的</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">Work</span> <span class="hljs-variable">work</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Work</span>();    work.a();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;    b();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// do something</span>&#125;</code></pre></div><p>接下来我们来具体分析一下虚拟机栈帧的结构</p><h3 id="局部变量表（Local-Variables-Table）"><a href="#局部变量表（Local-Variables-Table）" class="headerlink" title="局部变量表（Local Variables Table）"></a>局部变量表（Local Variables Table）</h3><p>顾名思义，局部变量表就是用于存放方法参数和方法内定义的局部变量。包括 8 种基本数据类型、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可以是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向一条字节码指令的地址）<strong>。</strong></p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位，一个 32 bit 的数值会占用一个 Solt，而一个 64 bit 的数值则会占用两个连续的 Solt。</p><p>当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递，即从实参到形参的传递。如果执行的是实例方法（非静态），那么局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用（this）</p><p>在 Java 程序编译为 Class 文件时，就在方法的 Code 属性中的 <code>max_locals</code> 数据项中确定了该方法所需分配的局部变量表的最大容量（Slot 数量）。</p><h3 id="操作数栈（Operand-Stacks）"><a href="#操作数栈（Operand-Stacks）" class="headerlink" title="操作数栈（Operand Stacks）"></a>操作数栈（Operand Stacks）</h3><p>操作数栈是一个后入先出栈（LIFO）。当一个方法刚刚开始执行时，其操作数栈是空的。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈&#x2F;入栈操作。一个完整的方法执行期间往往包含多个这样出栈&#x2F;入栈的过程。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，一个 32 bit 的数值可以用一个单位的栈深度来存储，而 一个 64 bit 的数值则需要 2 个单位的栈深度保存。</p><p>操作数栈的最大深度会在编译的时候写入到方法的 Code 属性的 <code>max_stacks</code> 数据项中。</p><h3 id="动态链接-（Dynamic-Linking）"><a href="#动态链接-（Dynamic-Linking）" class="headerlink" title="动态链接 （Dynamic Linking）"></a>动态链接 （Dynamic Linking）</h3><p>每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法间的调用。</p><h3 id="方法出口-（Method-Invocation-Completion）"><a href="#方法出口-（Method-Invocation-Completion）" class="headerlink" title="方法出口 （Method Invocation Completion）"></a>方法出口 （Method Invocation Completion）</h3><p>当一个方法开始执行后，只有两种方式退出这个方法。</p><ul><li>当执行引擎遇到任何一个方法返回的字节码指令时会退出该方法，这种退出称之为：正常调用完成（Normal Method Invocation Completion）。</li><li>如果在方法执行过程中发生了异常，并且在方法体中没有得到处理，则会导致方法退出。这种退出方式称之为：异常调用完成（Abrupt Method Invocation Completion）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java Virtual Machine（JVM）是一种抽象的计算机，基于堆栈架构，它有自己的指令集和内存管理。它加载 class 文件、分</summary>
      
    
    
    
    <category term="Java" scheme="https://okayhu.github.io/blog/categories/Java/"/>
    
    
    <category term="jvm" scheme="https://okayhu.github.io/blog/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>通过 Docker 安装 Nginx</title>
    <link href="https://okayhu.github.io/blog/posts/2022/nginx-docker-install/"/>
    <id>https://okayhu.github.io/blog/posts/2022/nginx-docker-install/</id>
    <published>2022-06-21T13:28:22.000Z</published>
    <updated>2023-01-07T12:38:04.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>环境：CentOS 7</p></blockquote><h3 id="下载并启动镜像"><a href="#下载并启动镜像" class="headerlink" title="下载并启动镜像"></a>下载并启动镜像</h3><div class="code-wrapper"><pre><code class="hljs bash">docker run --name nginx -p 80:80 -d nginx:latest</code></pre></div><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>如果 80 端口未开放，执行以下命令</p><div class="code-wrapper"><pre><code class="hljs bash">firewall-cmd --premanent --add-port=80/tcp<span class="hljs-comment"># 也可以以service的方式开启</span>firewall-cmd --premanent --add-service=http<span class="hljs-comment"># 重新加载配置</span>firewall-cmd --reload<span class="hljs-comment"># 查看所有开启的端口</span>firewall-cmd --list-port<span class="hljs-comment"># 查看所有开启的服务</span>firewall-cmd --list-service</code></pre></div><h3 id="挂载配置"><a href="#挂载配置" class="headerlink" title="挂载配置"></a>挂载配置</h3><p>将 nginx 的配置文件以及 html 文件拷贝到宿主机</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将 /usr/local/docker/nginx/ 换成你想存放的目录</span><span class="hljs-built_in">mkdir</span> -p /usr/local/docker/nginx/&#123;conf,<span class="hljs-built_in">log</span>,html&#125;docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/nginx.conf /usr/local/docker/nginx/conf/nginx.confdocker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/conf.d /usr/local/docker/nginx/conf/conf.ddocker <span class="hljs-built_in">cp</span> nginx:/usr/share/nginx/html /usr/local/docker/nginx/html</code></pre></div><h3 id="额外的命令"><a href="#额外的命令" class="headerlink" title="额外的命令"></a>额外的命令</h3><p>停止并删除 nginx 容器</p><div class="code-wrapper"><pre><code class="hljs bash">docker stop nginxdocker <span class="hljs-built_in">rm</span> nginx<span class="hljs-comment"># 可以删除还在运行的容器</span>docker <span class="hljs-built_in">rm</span> -f nginx</code></pre></div><p>重新启动 nginx 容器</p><div class="code-wrapper"><pre><code class="hljs bash">docker run --name nginx -p 80:80 \\-v /usr/local/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /usr/local/docker/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /usr/local/docker/nginx/html:/usr/share/nginx/html \\-v /usr/local/docker/nginx/log:/var/log/nginx \\-d nginx:latest</code></pre></div><p>如果要修改 nginx 配置，可以直接修改 <code>usr/local/docker/nginx/conf/nginx.conf</code> 文件，并执行</p><div class="code-wrapper"><pre><code class="hljs bash">docker restart nginx</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;环境：CentOS 7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;下载并启动镜像&quot;&gt;&lt;a href=&quot;#下载并启动镜像&quot; class=&quot;headerlink&quot; title=&quot;下载并启动镜像&quot;&gt;&lt;/a&gt;下载并启动镜像&lt;/h3&gt;&lt;div cl</summary>
      
    
    
    
    <category term="Devops" scheme="https://okayhu.github.io/blog/categories/Devops/"/>
    
    
    <category term="docker" scheme="https://okayhu.github.io/blog/tags/docker/"/>
    
    <category term="nginx" scheme="https://okayhu.github.io/blog/tags/nginx/"/>
    
  </entry>
  
</feed>
