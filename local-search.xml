<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IDEA：通过 Groovy 脚本生成 Entity</title>
    <link href="/blog/2022/12/12/IDEA%EF%BC%9A%E9%80%9A%E8%BF%87%20Groovy%20%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%20Entity/"/>
    <url>/blog/2022/12/12/IDEA%EF%BC%9A%E9%80%9A%E8%BF%87%20Groovy%20%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%20Entity/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA-连接数据库"><a href="#IDEA-连接数据库" class="headerlink" title="IDEA 连接数据库"></a>IDEA 连接数据库</h3><p>IDEA 内置了 DataGrip 的大部分功能用于管理数据库，可在侧边栏找到，连接到数据库。</p><p><img src="/blog/images/idea/idea-database-groovy-01.png"></p><h3 id="定位-Groovy-脚本目录"><a href="#定位-Groovy-脚本目录" class="headerlink" title="定位 Groovy 脚本目录"></a>定位 Groovy 脚本目录</h3><p>IDEA 已经内置了几个用于生成模型类的脚本，我们可以根据自己需求创建自己的脚本。</p><p>在任意表中右键选择脚本扩展 - 转到脚本目录。</p><p><img src="/blog/images/idea/idea-database-groovy-02.png"></p><p>点击 <code>Go To Scripts Directory</code> 然后就可以看到内置的脚本文件，双击就可以编辑，也可以新增。</p><p><img src="/blog/images/idea/idea-database-groovy-03.png"></p><h3 id="编写-Groovy-脚本文件"><a href="#编写-Groovy-脚本文件" class="headerlink" title="编写 Groovy 脚本文件"></a>编写 Groovy 脚本文件</h3><p>下面这个脚本是基于 <code>MyBatis-Plus + Lombok</code> 的：</p><div class="code-wrapper"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> com.intellij.database.model.DasTable<span class="hljs-keyword">import</span> com.intellij.database.util.Case<span class="hljs-keyword">import</span> com.intellij.database.util.DasUtil<span class="hljs-comment">/*</span><span class="hljs-comment"> * Available context bindings:</span><span class="hljs-comment"> *   SELECTION   Iterable&lt;DasObject&gt;</span><span class="hljs-comment"> *   PROJECT     project</span><span class="hljs-comment"> *   FILES       files helper</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Tips: the script does  not support the composite primary key</span><span class="hljs-comment"> */</span>packageName = <span class="hljs-string">&quot;&quot;</span>existsPrimaryKey = <span class="hljs-literal">false</span>;primaryKeyAutoGenerated = <span class="hljs-literal">false</span>;typeMapping = [        (<span class="hljs-regexp">~/(?i)tinyint|bool|boolean|bit/</span>)        : <span class="hljs-string">&quot;Boolean&quot;</span>,        (<span class="hljs-regexp">~/(?i)bigint/</span>)                          : <span class="hljs-string">&quot;Long&quot;</span>,        (<span class="hljs-regexp">~/(?i)smallint|mediumint|int|integer/</span>)  : <span class="hljs-string">&quot;Integer&quot;</span>,        (<span class="hljs-regexp">~/(?i)float/</span>)                           : <span class="hljs-string">&quot;Float&quot;</span>,        (<span class="hljs-regexp">~/(?i)double/</span>)                          : <span class="hljs-string">&quot;Double&quot;</span>,        (<span class="hljs-regexp">~/(?i)decimal/</span>)                         : <span class="hljs-string">&quot;BigDecimal&quot;</span>,        (<span class="hljs-regexp">~/(?i)date|datetime|timestamp|time/</span>)    : <span class="hljs-string">&quot;Date&quot;</span>,        (<span class="hljs-regexp">~/(?i)char|varchar|text|json/</span>)          : <span class="hljs-string">&quot;String&quot;</span>,        (<span class="hljs-regexp">~/(?i)blob|binary|bfile|clob|raw|image/</span>): <span class="hljs-string">&quot;InputStream&quot;</span>,        (<span class="hljs-regexp">~/^(?i)/</span>)                               : <span class="hljs-string">&quot;String&quot;</span>]FILES.chooseDirectoryAndSave(<span class="hljs-string">&quot;Choose directory&quot;</span>, <span class="hljs-string">&quot;Choose where to store generated files&quot;</span>) &#123; dir -&gt;    SELECTION.filter &#123; it <span class="hljs-keyword">instanceof</span> DasTable &#125;.each &#123; generate(it, dir) &#125;&#125;<span class="hljs-keyword">def</span> generate(table, dir) &#123;    <span class="hljs-keyword">def</span> className = javaName(table.getName(), <span class="hljs-literal">true</span>)    <span class="hljs-keyword">def</span> fields = calcFields(table)    packageName = getPackageName(dir)    <span class="hljs-keyword">new</span> File(dir, className + <span class="hljs-string">&quot;.java&quot;</span>).withPrintWriter(<span class="hljs-string">&quot;UTF-8&quot;</span>) &#123; out -&gt; generate(out, className, fields, table) &#125;&#125;<span class="hljs-keyword">def</span> generate(out, className, fields, table) &#123;    out.println <span class="hljs-string">&quot;package $packageName&quot;</span>    out.println <span class="hljs-string">&quot;&quot;</span>    Set types = <span class="hljs-keyword">new</span> HashSet()    fields.each() &#123;        types.add(it.type)    &#125;    <span class="hljs-comment">// In the order of IDEA formatting</span>    <span class="hljs-keyword">if</span> (primaryKeyAutoGenerated) &#123;        out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.IdType;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.TableField;&quot;</span>    <span class="hljs-keyword">if</span> (existsPrimaryKey) &#123;        out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.TableId;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;import com.baomidou.mybatisplus.annotation.TableName;&quot;</span>    <span class="hljs-keyword">if</span> (types.contains(<span class="hljs-string">&quot;InputStream&quot;</span>)) &#123;        out.println <span class="hljs-string">&quot;import java.io.InputStream;&quot;</span>    &#125;    <span class="hljs-keyword">if</span> (types.contains(<span class="hljs-string">&quot;BigDecimal&quot;</span>)) &#123;        out.println <span class="hljs-string">&quot;import java.math.BigDecimal;&quot;</span>    &#125;    <span class="hljs-keyword">if</span> (types.contains(<span class="hljs-string">&quot;Date&quot;</span>)) &#123;        out.println <span class="hljs-string">&quot;import java.util.Date;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;import lombok.Getter;&quot;</span>    out.println <span class="hljs-string">&quot;import lombok.Setter;&quot;</span>    out.println <span class="hljs-string">&quot;import lombok.ToString;&quot;</span>    out.println <span class="hljs-string">&quot;&quot;</span>    out.println <span class="hljs-string">&quot;@Getter&quot;</span>    out.println <span class="hljs-string">&quot;@Setter&quot;</span>    out.println <span class="hljs-string">&quot;@ToString&quot;</span>    out.println <span class="hljs-string">&quot;@TableName(\&quot;&quot;</span> + table.getName() + <span class="hljs-string">&quot;\&quot;)&quot;</span>    out.print <span class="hljs-string">&quot;public class $className &#123;&quot;</span>    out.println <span class="hljs-string">&quot;&quot;</span>    fields.each &#123; it -&gt;        out.println <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-comment">// Print comments</span>        <span class="hljs-keyword">if</span> (isNotEmpty(it.comment)) &#123;            out.println <span class="hljs-string">&quot;    /**&quot;</span>            out.println <span class="hljs-string">&quot;     * $&#123;it.comment.toString()&#125;&quot;</span>            out.println <span class="hljs-string">&quot;     */&quot;</span>        &#125;        <span class="hljs-comment">// Print annotations</span>        it.annos.each &#123; anno -&gt;            out.println <span class="hljs-string">&quot;    $&#123;anno&#125;&quot;</span>        &#125;        out.println <span class="hljs-string">&quot;    private $&#123;it.type&#125; $&#123;it.name&#125;;&quot;</span>    &#125;    out.println <span class="hljs-string">&quot;&#125;&quot;</span>&#125;<span class="hljs-keyword">def</span> calcFields(table) &#123;    DasUtil.getColumns(table).reduce([]) &#123; fields, col -&gt;        <span class="hljs-keyword">def</span> spec = Case.LOWER.apply(col.getDataType().getSpecification())        <span class="hljs-keyword">def</span> typeStr = typeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value        <span class="hljs-keyword">def</span> annos = []        <span class="hljs-keyword">if</span> (DasUtil.isPrimary(col)) &#123;            existsPrimaryKey = <span class="hljs-literal">true</span>            <span class="hljs-keyword">if</span> (DasUtil.isAutoGenerated(col)) &#123;                primaryKeyAutoGenerated = <span class="hljs-literal">true</span>                annos += [<span class="hljs-string">&quot;@TableId(value = \&quot;&quot;</span> + col.getName() + <span class="hljs-string">&quot;\&quot;, type = IdType.AUTO)&quot;</span>]            &#125; <span class="hljs-keyword">else</span> &#123;                annos += [<span class="hljs-string">&quot;@TableId(\&quot;&quot;</span> + col.getName() + <span class="hljs-string">&quot;\&quot;)&quot;</span>]            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            annos += [<span class="hljs-string">&quot;@TableField(\&quot;&quot;</span> + col.getName() + <span class="hljs-string">&quot;\&quot;)&quot;</span>]        &#125;        fields += [[                           <span class="hljs-attr">name   :</span> javaName(col.getName(), <span class="hljs-literal">false</span>),                           <span class="hljs-attr">type   :</span> typeStr,                           <span class="hljs-attr">annos  :</span> annos,                           <span class="hljs-symbol">comment:</span> col.getComment()                   ]]    &#125;&#125;<span class="hljs-keyword">def</span> javaName(str, capitalize) &#123;    str = str.startsWith(<span class="hljs-string">&quot;is_&quot;</span>) ? str.substring(<span class="hljs-number">3</span>) : str    <span class="hljs-keyword">def</span> s = com.intellij.psi.codeStyle.NameUtil.splitNameIntoWords(str)            .collect &#123; Case.LOWER.apply(it).capitalize() &#125;            .join(<span class="hljs-string">&quot;&quot;</span>)            .replaceAll(<span class="hljs-regexp">/[^\p&#123;javaJavaIdentifierPart&#125;[_]]/</span>, <span class="hljs-string">&quot;_&quot;</span>)    capitalize || s.length() == <span class="hljs-number">1</span> ? s : Case.LOWER.apply(s[<span class="hljs-number">0</span>]) + s[<span class="hljs-number">1.</span>.<span class="hljs-number">-1</span>]&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> getPackageName(dir) &#123;    <span class="hljs-keyword">return</span> dir.toString()            .replaceAll(<span class="hljs-string">&quot;\\\\&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>)            .replaceAll(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>)            .replaceAll(<span class="hljs-string">&quot;^.*src(\\.main\\.java\\.)?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;;&quot;</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> isNotEmpty(content) &#123;    <span class="hljs-keyword">return</span> content != <span class="hljs-literal">null</span> &amp;&amp; content.toString().trim().length() &gt; <span class="hljs-number">0</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea, groovy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 之内存结构</title>
    <link href="/blog/2022/06/22/JVM%20%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2022/06/22/JVM%20%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java Virtual Machine（JVM）是一种抽象的计算机，基于堆栈架构，它有自己的指令集和内存管理。它加载 class 文件、分析、解释并执行字节码。基本结构如下：</p><p><img src="/blog/images/jvm/jvm-memory-structure-01.png"></p><p>Java 虚拟机会在执行 Java 程序的过程中把它所管理的内存划分为若干区域。如图：</p><p><img src="/blog/images/jvm/jvm-memory-structure-02.png"></p><p>JVM 内存结构主要分为三大块：堆、栈和方法区。堆是 JVM 中最大的一块区域，由年轻代和老年代组成，而年轻代内存又分成两部分，Eden 区和 Survivor 区，而 Survivor 区又分为 From 区、To 区，默认情况下年轻代按照 8:1:1 的比例来分配。</p><p>通过一张图来了解如何通过参数来控制各区域的内存大小：</p><p><img src="/blog/images/jvm/jvm-memory-structure-03.png"></p><ul><li>_Xms_：设置堆的最小空间大小。</li><li>_Xmx_：设置堆的最大空间大小。</li><li>_XX:NewSize_：设置新生代最小空间大小。</li><li>_XX:MaxNewSize_：设置新生代最大空间大小。</li><li>_XX:PermSize_：设置永久代最小空间大小。</li><li>_XX:MaxPermSize_：设置永久代最大空间大小。</li><li>_Xss_：设置每个线程的堆栈大小。</li></ul><div class="note note-info">            <p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。（老年代空间大小 &#x3D; 堆空间大小 - 年轻代空间大小）</p>          </div><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>对于大多数应用来说，堆（Heap）是 Java 虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>堆是垃圾收集器管理的主要区域。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以堆中还可以细分为：新生代和老年代。当让再细分的话还要，Eden 区、From Survivor 区、To Survivor 区。</p><p>根据 Java 虚拟机规范的规定，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区（Method Area）与堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>对于习惯在 HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为 永久代（Permanent Generation），本质上两者并不等价。仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java 虚拟机规范对这个区域的限制非常宽松，除了和堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><div class="note note-info">            <p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样永久存在了。</p>          </div><p>根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p><h2 id="程序计数器（The-pc-Register）"><a href="#程序计数器（The-pc-Register）" class="headerlink" title="程序计数器（The pc Register）"></a>程序计数器（The pc Register）</h2><p>程序计数器是线程私有的，它可以看作当前线程所执行的字节码的行号指示器。</p><p>在字节码解释器工作的时候就是通过改变程序计数器的值来选取和记录下一条要执行的字节码指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都要依赖其完成。</p><ul><li>如果线程正在执行一个 Java 方法，那么程序计数器记录的是正在执行的虚拟机字节码指令的地址。</li><li>如果正在执行的是一个本地（Native）方法，则计数器值为空（Undefined）。</li></ul><div class="note note-info">            <p>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>          </div><h2 id="虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="虚拟机栈（Java Virtual Machine Stacks）"></a>虚拟机栈（Java Virtual Machine Stacks）</h2><p>每个线程都有一个私有 Java 虚拟机栈，与该线程同时创建，同时销毁。它保存局部变量和部分结果，并在方法调用和返回中起作用。Java 虚拟机堆栈的内存不必是连续的。</p><p>Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：每一个方法在执行的同时都会创建一个栈帧（Frames），用于存储 局部变量表、操作数栈、动态链接、方法出口 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程。</p><ul><li>每个方法对应一个栈帧</li><li>栈的数据结构是先进后出（FILO）的</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">Work</span> <span class="hljs-variable">work</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Work</span>();    work.a();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;    b();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// do something</span>&#125;</code></pre></div><p>接下来我们来具体分析一下虚拟机栈帧的结构</p><h3 id="局部变量表（Local-Variables-Table）"><a href="#局部变量表（Local-Variables-Table）" class="headerlink" title="局部变量表（Local Variables Table）"></a>局部变量表（Local Variables Table）</h3><p>顾名思义，局部变量表就是用于存放方法参数和方法内定义的局部变量。包括 8 种基本数据类型、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可以是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向一条字节码指令的地址）<strong>。</strong></p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位，一个 32 bit 的数值会占用一个 Solt，而一个 64 bit 的数值则会占用两个连续的 Solt。</p><p>当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递，即从实参到形参的传递。如果执行的是实例方法（非静态），那么局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用（this）</p><p>在 Java 程序编译为 Class 文件时，就在方法的 Code 属性中的 <code>max_locals</code> 数据项中确定了该方法所需分配的局部变量表的最大容量（Slot 数量）。</p><h3 id="操作数栈（Operand-Stacks）"><a href="#操作数栈（Operand-Stacks）" class="headerlink" title="操作数栈（Operand Stacks）"></a>操作数栈（Operand Stacks）</h3><p>操作数栈是一个后入先出栈（LIFO）。当一个方法刚刚开始执行时，其操作数栈是空的。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈&#x2F;入栈操作。一个完整的方法执行期间往往包含多个这样出栈&#x2F;入栈的过程。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，一个 32 bit 的数值可以用一个单位的栈深度来存储，而 一个 64 bit 的数值则需要 2 个单位的栈深度保存。</p><p>操作数栈的最大深度会在编译的时候写入到方法的 Code 属性的 <code>max_stacks</code> 数据项中。</p><h3 id="动态链接-（Dynamic-Linking）"><a href="#动态链接-（Dynamic-Linking）" class="headerlink" title="动态链接 （Dynamic Linking）"></a>动态链接 （Dynamic Linking）</h3><p>每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法间的调用。</p><h3 id="方法出口-（Method-Invocation-Completion）"><a href="#方法出口-（Method-Invocation-Completion）" class="headerlink" title="方法出口 （Method Invocation Completion）"></a>方法出口 （Method Invocation Completion）</h3><p>当一个方法开始执行后，只有两种方式退出这个方法。</p><ul><li>当执行引擎遇到任何一个方法返回的字节码指令时会退出该方法，这种退出称之为：正常调用完成（Normal Method Invocation Completion）。</li><li>如果在方法执行过程中发生了异常，并且在方法体中没有得到处理，则会导致方法退出。这种退出方式称之为：异常调用完成（Abrupt Method Invocation Completion）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过 Docker 安装 Nginx</title>
    <link href="/blog/2021/06/21/%E9%80%9A%E8%BF%87%20Docker%20%E5%AE%89%E8%A3%85%20Nginx/"/>
    <url>/blog/2021/06/21/%E9%80%9A%E8%BF%87%20Docker%20%E5%AE%89%E8%A3%85%20Nginx/</url>
    
    <content type="html"><![CDATA[<blockquote><p>环境：CentOS 7</p></blockquote><h3 id="下载并启动镜像"><a href="#下载并启动镜像" class="headerlink" title="下载并启动镜像"></a>下载并启动镜像</h3><div class="code-wrapper"><pre><code class="hljs bash">docker run --name nginx -p 80:80 -d nginx:latest</code></pre></div><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>如果 80 端口未开放，执行以下命令</p><div class="code-wrapper"><pre><code class="hljs bash">firewall-cmd --premanent --add-port=80/tcp<span class="hljs-comment"># 也可以以service的方式开启</span>firewall-cmd --premanent --add-service=http<span class="hljs-comment"># 重新加载配置</span>firewall-cmd --reload<span class="hljs-comment"># 查看所有开启的端口</span>firewall-cmd --list-port<span class="hljs-comment"># 查看所有开启的服务</span>firewall-cmd --list-service</code></pre></div><h3 id="挂载配置"><a href="#挂载配置" class="headerlink" title="挂载配置"></a>挂载配置</h3><p>将 nginx 的配置文件以及 html 文件拷贝到宿主机</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将 /usr/local/docker/nginx/ 换成你想存放的目录</span><span class="hljs-built_in">mkdir</span> -p /usr/local/docker/nginx/&#123;conf,<span class="hljs-built_in">log</span>,html&#125;docker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/nginx.conf /usr/local/docker/nginx/conf/nginx.confdocker <span class="hljs-built_in">cp</span> nginx:/etc/nginx/conf.d /usr/local/docker/nginx/conf/conf.ddocker <span class="hljs-built_in">cp</span> nginx:/usr/share/nginx/html /usr/local/docker/nginx/html</code></pre></div><h3 id="额外的命令"><a href="#额外的命令" class="headerlink" title="额外的命令"></a>额外的命令</h3><p>停止并删除 nginx 容器</p><div class="code-wrapper"><pre><code class="hljs bash">docker stop nginxdocker <span class="hljs-built_in">rm</span> nginx<span class="hljs-comment"># 可以删除还在运行的容器</span>docker <span class="hljs-built_in">rm</span> -f nginx</code></pre></div><p>重新启动 nginx 容器</p><div class="code-wrapper"><pre><code class="hljs bash">docker run --name nginx -p 80:80 \\-v /usr/local/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /usr/local/docker/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /usr/local/docker/nginx/html:/usr/share/nginx/html \\-v /usr/local/docker/nginx/log:/var/log/nginx \\-d nginx:latest</code></pre></div><p>如果要修改 nginx 配置，可以直接修改 <code>usr/local/docker/nginx/conf/nginx.conf</code> 文件，并执行</p><div class="code-wrapper"><pre><code class="hljs bash">docker restart nginx</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx, docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
