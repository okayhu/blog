---
title: JVM 之 对象引用与垃圾回收算法
sub_title: jvm-object-gc
index_img: /images/jvm/jvm.png
date: 2022-07-18 22:08:11
categories: Java
tags: jvm
---

## 引用的分类

**强引用**：我们平时 new 了一个对象就是强引用，例如 `Object obj = new Object()`。即使在内存不足的情况下，JVM 宁愿抛出 OutOfMemory 错误也不会回收这种对象。

<!--truncate-->

**软引用**：如果一个对象只具有软引用，则内存空间足够，垃圾回收器不会回收它，如果内存不足，则在发生内存溢出之前被回收。

```java
SoftReference<String> softRef = new SoftReference<String>(str);
```

**弱引用**：具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器进行垃圾回收时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

```java
WeakReference<String> weakRef = new WeakReference<String>(str);
```

**虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

```java
ReferenceQueue queue = new ReferenceQueue();
PhantomReference phantomRef = new PhantomReference(str, queue);
```

## 什么是垃圾

没有任何引用的对象。

## 如何判断对象没有任何引用

### 引用计数器法

为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。

{% note info %}
引用计数器无法解决循环应用的问题。
{% endnote %}

### 可达性分析算法

从 GC Roots 开始向下搜索，搜索所走过的路径称为 `引用链（Reference Chain）`。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：

- **虚拟机栈（栈帧中的本地变量表）中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等**。
- **方法区中类静态属性引用的对象、java 类的引用类型静态变量**。
- **方法区中常量引用的对象。比如：字符串常量池里的引用**。
- **本地方法栈中 JNI（即一般说的 Native 方法）引用的对象**。
- JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。
- 所有被同步锁（synchronized 关键字）持有的对象。
- JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。
- JVM 实现中的临时性对象，跨代引用的对象。

以上的回收都是对象，类（Class）的回收条件非常苛刻，必须同时满足以下的条件（仅仅是可以，不代表必然，因为还有一些参数可以进行控制）

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

`-Xnoclassgc`：禁用类的垃圾回收。

废弃的常量和静态变量的回收其实就和 Class 回收的条件差不多。

**Finalize**

Object 类中的 finalize() 方法类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用 finalize()。

{% note info %}
当一个对象可被回收时，如果执行该对象的 finalize() 方法，只能说**有可能**通过在该方法中让对象重新被引用，从而实现自救。
{% endnote %}

## 垃圾回收算法

### 复制算法（Copying）

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

复制回收算法适合于新生代。因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高。

### 标记-清除算法（Mark-Sweep）

算法分为标记和清除两个阶段。首先扫描出所有对象并标记出需要回收的对象，在标记完成后扫描回收所有被标记的对象，所以需要扫描两遍。回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，对比复制回收效率要低，所以标记清除算法适用于老年代。

标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

### 标记-整理算法（Mark-Compact）

算法分为标记和整理两个阶段：首先标记出所有需要回收的对象，在标记完成后，不是直接对可回收对象进行清理，而是将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。

标记整理算法虽然没有内存碎片，但是效率偏低。我们看到标记整理算法与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用对象的地方都需要更新（直接指针需要调整）。
